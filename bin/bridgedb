#!/usr/bin/env node

var _ = require("lodash");
var crypto = require("crypto");
var csv = require("csv-streamify");
var fs = require("fs");
var BridgeDb = require("../lib").BridgeDb;
var hl = require("highland");
var ndjson = require("ndjson");
var npmPackage = require("../package.json");
var program = require("commander");
var Rx = require("rx-extra");
require("../lib/topublish/pipeToStdout");
var VError = require("verror");

program
  .version(npmPackage.version)
  .description("CLI client for BridgeDb ID mapping webservice.");

program.on("--help", function() {
  console.log("  Examples:");
  console.log();
  console.log("    Display xrefs in command line:");
  console.log("    $ bridgedb xrefs 'Homo sapiens' 'Entrez Gene' 1234");
  console.log();
  console.log("    Save multiple xrefs to new file:");
  console.log(
    [
      "    $ cat test/dbNamesAndIds.csv | bridgedb xrefsBatch ",
      "--organism='Homo sapiens' > ./xrefs.json"
    ].join("")
    /* TODO why doesn't the following work?
    [
      "    $ bridgedb xrefsBatch ",
      "--organism='Homo sapiens' --dbConventionalName='Entrez Gene' ",
      "< ./test/dbNamesAndIds.csv > ./xrefs.json"
    ].join("")
    //*/
  );
});

// npm run compile:es5 && ./bin/bridgedb xrefs 'Homo sapiens' 'Entrez Gene' '1234'
program
  .command("xrefs <organism> <dbConventionalName> <dbId>")
  .action(function(organism, dbConventionalName, dbId) {
    var bridgeDb = new BridgeDb();

    var serialize = ndjson.serialize();
    bridgeDb
      .xrefs(organism, dbConventionalName, dbId)
      .throughNodeStream(serialize)
      .pipeToStdout();
  });

/*
Compile, if needed:
npm run compile:es5

Run it, as in one of the following examples:

echo $'1234\n1235\n' | ./bin/bridgedb xrefsBatch --organism 'Homo sapiens' --dbConventionalName 'Entrez Gene'

./bin/bridgedb xrefsBatch --organism 'Homo sapiens' --dbConventionalName 'Entrez Gene' <<< $'1234\n1235\n'

echo $'dbId\n1234\n1235\n' | ./bin/bridgedb xrefsBatch --organism 'Homo sapiens'
    --dbConventionalName 'Entrez Gene' --headers=true

cat test/dbIds.csv | ./bin/bridgedb xrefsBatch --organism="Homo sapiens" --dbConventionalName="Entrez Gene"

./bin/bridgedb xrefsBatch --organism="Homo sapiens" < test/dbNamesAndIds.csv

cat test/dbNamesAndIds.csv | ./bin/bridgedb xrefsBatch --organism="Homo sapiens"
*/
program
  .command(
    "xrefsBatch [dbIdColumn] [dbConventionalNameColumn] [organismColumn]"
  )
  .description("Get xrefs for entities in a delimited file (CSV, TSV, etc.)")
  .option(
    "-d, --delimiter [string]",
    'Delimiter for file, e.g., "," or "\t". Default: ","'
  )
  .option(
    "--organism [string]",
    'If organismColumn not specified, set organism, e.g., "Homo sapiens"'
  )
  .option(
    "--dbConventionalName [string]",
    'If dbConventionalNameColumn not specified, set dbConventionalName, e.g., "Entrez Gene"'
  )
  .option("--headers [boolean]", "First row of file is headers")
  .action(function(
    dbIdColumnStr,
    dbConventionalNameColumnStr,
    organismColumnStr,
    options
  ) {
    var organismOption = options.organism;
    var dbConventionalNameOption = options.dbConventionalName;
    var headersOption = options.hasOwnProperty("headers")
      ? Boolean(options.headers)
      : false;
    var delimiterOption = options.delimiter || ",";
    var newlineOption = options.newline || "\n"; // newline character (use \r\n for CRLF files)
    var quoteOption = options.quote || '"';

    var organismColumn = typeof organismColumnStr !== "undefined"
      ? parseInt(organismColumnStr)
      : typeof organismOption === "undefined" ? 0 : null;

    var dbConventionalNameColumn = typeof dbConventionalNameColumnStr !==
      "undefined"
      ? parseInt(dbConventionalNameColumnStr)
      : typeof dbConventionalNameOption === "undefined"
        ? organismColumn === null ? 0 : organismColumn + 1
        : null;

    var dbIdColumn = typeof dbIdColumnStr !== "undefined"
      ? parseInt(dbIdColumnStr)
      : typeof dbIdOption === "undefined"
        ? dbConventionalNameColumn === null ? 0 : dbConventionalNameColumn + 1
        : null;

    var bridgeDb = new BridgeDb();

    var parser = csv({
      delimiter: delimiterOption,
      newline: newlineOption,
      quote: quoteOption,
      objectMode: true
    });

    var serialize = ndjson.serialize();

    Rx.Observable
      .fromNodeReadableStream(
        hl(process.stdin).through(parser).drop(headersOption ? 1 : 0)
      )
      .mergeMap(function(row) {
        var organism = typeof organismOption !== "undefined"
          ? organismOption
          : row[organismColumn];
        var dbConventionalName = typeof dbConventionalNameOption !== "undefined"
          ? dbConventionalNameOption
          : row[dbConventionalNameColumn];
        var dbId = typeof dbIdOption !== "undefined"
          ? dbIdOption
          : row[dbIdColumn];
        return bridgeDb
          .dataSourceProperties(dbConventionalName)
          .mergeMap(function(dataSource) {
            var id = dataSource.id + dbId;
            return bridgeDb
              .xrefs(organism, dbConventionalName, dbId)
              .toArray()
              .map(function(xrefs) {
                return {
                  id: id,
                  dbConventionalName: dbConventionalName,
                  dbId: dbId,
                  organism: organism,
                  xrefs: xrefs
                };
              });
          });
      })
      .throughNodeStream(serialize)
      .pipeToStdout();
  });

program.parse(process.argv);
