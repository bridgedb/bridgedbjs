#!/usr/bin/env node

var replaceStream = require('replacestream')
var _ = require("lodash");
var crypto = require("crypto");
// TODO does csv follow this: https://tools.ietf.org/html/rfc4180
var csv = require("csv-streamify");
var fs = require("fs");
var jsonpath = require('jsonpath');
var path = require("path");
var BridgeDb = require("../es5/BridgeDb").BridgeDb;
var hl = require("highland");
var ndjson = require("ndjson");
var JSONStream = require("JSONStream");
var npmPackage = require("../package.json");
var program = require("commander");
var Rx = require("rx-extra");
require("../es5/spinoffs/pipeToStdout");
require("../es5/spinoffs/toNodeStream");
var VError = require("verror");

program
  .version(npmPackage.version)
  .description("CLI client for BridgeDb Identifier mapping webservice.");

//program.on("--help", function() {
//  console.log("  Examples:");
//  console.log();
//  console.log("    Display xrefs in command line:");
//  console.log("    $ bridgedb xrefs 'Homo sapiens' 'Entrez Gene' 1234");
//  console.log();
//  console.log("    Save multiple xrefs to new file:");
//  console.log(
//    [
//      "    $ cat test/xrefDataSourcesAndIdentifiers.csv | bridgedb xrefsBatch ",
//      "--organism='Homo sapiens' > ./xrefs.json"
//    ].join("")
//    /* TODO why doesn't the following work?
//    [
//      "    $ bridgedb xrefsBatch ",
//      "--organism='Homo sapiens' --xrefDataSource='Entrez Gene' ",
//      "< ./test/xrefDataSourcesAndIdentifiers.csv > ./xrefs.json"
//    ].join("")
//    //*/
//  );
//});

// path options
// https://www.npmjs.com/package/node-red-contrib-json
// JSONata: https://github.com/jsonata-js/jsonata/blob/master/tutorial.md
// JSON Path: http://goessner.net/articles/JsonPath/
// jq
// ...

function jsonPathToLodashPath(jsonPath) {
  const jsonPathParsed = parseJsonPath(jsonPath);
  const unhandledOperators = _.intersection(jsonPathParsed, ["..", "*"]);
  if (unhandledOperators.length > 0) {
    throw new Error(`Cannot currently handle ${unhandledOperators.join()} operator(s).`);
  }
  return jsonPathParsed.filter(s => s !== "$").map(s => s === true ? "*" : s).join(".");
}

function serializeJsonPath(pathComponents) {
  const unhandledOperators = _.intersection(pathComponents, [".."]);
  if (unhandledOperators.length > 0) {
    throw new Error(`Cannot currently handle ${unhandledOperators.join()} operator(s).`);
  }
  return pathComponents.map(s => s === true ? "*" : s).join(".");
}

function parseJsonPath(path) {
  if (path.indexOf("..") > -1) {
    throw new Error('Cannot currently handle ".." operator.');
  }
  return path.split(".").map(s => s === "*" ? true : s);
}

/************
 * jq
 **********/

function jqToJSONStreamPath(jqPath) {
  const jqPathParsed = parseJQPath(jqPath);
  const unhandledOperators = _.intersection(jqPathParsed, [".."]);
  if (unhandledOperators.length > 0) {
    throw new Error(`Cannot currently handle ${unhandledOperators.join()} operator(s).`);
  }
  return jqPathParsed.map(s => s === true ? "*" : s).join(".");
}

function jqPathToLodashParsedPath(jqPath) {
  const jqPathParsed = parseJQPath(jqPath);
  const unhandledOperators = _.intersection(jqPathParsed, ["..", true]);
  if (unhandledOperators.length > 0) {
    throw new Error(`Cannot currently handle ${unhandledOperators.join()} operator(s).`);
  }
  return jqPathParsed;
}

/*
function serializeJQPath(pathComponents) {
  const unhandledOperators = _.intersection(pathComponents, [".."]);
  if (unhandledOperators.length > 0) {
    throw new Error(`Cannot currently handle ${unhandledOperators.join()} operator(s).`);
  }
  return pathComponents.map(s => s === true ? "*" : s).join(".");
}
//*/

function parseJQPath(path) {
  return path.replace(/^\./, "")
    .split(".")
    .reduce((acc, s) => {
      (s.match(/(\w+)?(\[\w*\])?/) || [])
        .slice(1)
        .filter(_.negate(_.isUndefined))
        .map(s => s === "[]" ? true : s.replace(/\[(\w+)\]/, "\1"))
        //.map(s => s.replace(/\[(\w+)\]/, "\1").replace(/\[\]/, true))
        .forEach(function(s) {
          acc.push(s);
        });
      return acc;
    }, []);
}

function resolveJQPath(base, relativePath) {
  if (base.endsWith(".") && relativePath.startsWith(".")) {
    return base + relativePath.replace(/^\./, "");
  } else if (base.endsWith(".") || relativePath.startsWith(".")) {
    return base + relativePath;
  } else {
    return base + "." + relativePath;
  }
}

/* _.get doesn't allow for path to indicate identity.
 * this function allows the parsed path to be [], indicating
 * we just want to return the entire value.
 */
function getByParsedPath(value, path) {
  if (path.length > 0) {
    return _.get(
      value,
      path
    );
  } else {
    return value;
  }
}

const DEFAULT_ADDMAPPEDXREFS_BASE = ".";
const NEST0_OBJECT_KEY = "BRIDGEDB_NEST0_OBJECT_KEY";
program
  .command(
    `addAlternateXrefs <organism> <pathToXrefDataSource> <pathToXrefIdentifier>
    <pathToInsertionPoint> [desiredXrefDataSource...]`
  )
  .option(
    "-b,--base [path]",
    `jq expression that is prepended to relative paths.
                  Default: "${DEFAULT_ADDMAPPEDXREFS_BASE}"

                  It's similar in concept to HTML and XML BASE. More info:
                  https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base
                  https://www.w3.org/TR/xmlbase/`,
    (base) => !!base ? base : DEFAULT_ADDMAPPEDXREFS_BASE
  )
  .action(function(
    organism,
    pathToXrefDataSource,
    pathToXrefIdentifier,
    pathToInsertionPoint,
    desiredXrefDataSources,
    optionsRaw
  ) {
    var bridgeDb = new BridgeDb();

    const options = _.defaults(optionsRaw, {
      base: DEFAULT_ADDMAPPEDXREFS_BASE
    });
    var base = options.base;

    var {common, relPaths} = _.zip
      .apply(
        undefined,
        [pathToXrefDataSource, pathToXrefIdentifier]
          .map(p => resolveJQPath(base, p)).map(parseJQPath)
      )
      .reduce(
        function(acc, pair, i) {
          const {common, relPaths} = acc;
          const [first, second] = pair;
          acc.matched = acc.matched && first === second;
          if (acc.matched) {
            common.push(first);
          } else {
            pair.forEach(function(p, i) {
              if (acc.relPaths[i]) {
                acc.relPaths[i].push(p);
              } else {
                acc.relPaths[i] = [p];
              }
            });
          }
          return acc;
        },
        { matched: true, common: [], relPaths: [] }
      );

    const commonIndexOfTrue = common.indexOf(true);
    var JSONStreamParentPath = common.slice(
      0,
      commonIndexOfTrue > -1 ? commonIndexOfTrue : common.length - 1
    );
    var JSONStreamPath;
    if (common.length > 0) {
      JSONStreamPath = _.concat(JSONStreamParentPath, [{emitPath: true}]);
    } else {
      JSONStreamPath = [];
      // NOTE: using emitPath doesn't work when the input is just one object (Map).
      // We want to get the following to be consistent with other inputs:
      // {"path": [], value: THE_INPUT_OBJECT}
      // But we actually get the key/value pairs of the input object.
      // So we need to use the kludge above.
      //var JSONStreamPath = [{emitPath: true}];
    }
    var containerParser = JSONStream.parse(JSONStreamPath.length > 0 ? JSONStreamPath : undefined);

    var rootKey = common[0];

    const [relPathToXrefDataSourceParsed, relPathToXrefIdentifierParsed] = relPaths;

    if (_.intersection(_.uniq(relPaths), [true]).length > 0) {
      if (common.lastIndexOf(true) > 1) {
        throw new Error(`Currently unable to handle more than one level of nesting before "[]".

        These are OK:
        .a
        .a.z
        .a.z.x
        .a.z.x.y
        .[]
        .[].z
        .[].z.y
        .[].z.y.x
        .a[]
        .a[].z
        .a[].z.y
        .a[].z.y.x
      
        These are not:
        .a.b[]
        .a.b.c[]
        `);
      } else {
      throw new Error(`There must only be one xrefDataSource per xrefIdentifier, but
      provided paths may violate that constraint.
      `);
      }
    }

    const pathToInsertionPointParsed = parseJQPath(resolveJQPath(base, pathToInsertionPoint));
    /*
    console.warn('common');
    console.warn(common);
    console.warn('JSONStreamParentPath');
    console.warn(JSONStreamParentPath);
    console.warn('relPaths');
    console.warn(relPaths);
    console.warn('pathToInsertionPointParsed');
    console.warn(pathToInsertionPointParsed);
    //*/
    const addLocally = pathToInsertionPointParsed.join().indexOf(common.join()) === 0;

    var headerStream = hl("header", containerParser).map(function(result) {
      return {
        event: "header",
        path: [],
        value: result
      };
    });

    var dataStream = hl("data", containerParser);

    var footerStream = hl("footer", containerParser).map(function(result) {
      return {
        event: "footer",
        path: [],
        value: result
      };
    });

    var endStream = hl("end", containerParser);

    var lastCommonKey = common.slice(-1)[0] || NEST0_OBJECT_KEY;
    var parsedDataStream = dataStream
      .map(function(data) {
        if (JSONStreamPath.length > 0) {
          return data;
        } else {
          // This kludge is needed to handle un-nested objects as input, e.g.,
          // {"id": "abc123", "xrefDataSource": "Entrez Gene", "xrefIdentifier": "1234"}
          // We want process them same way we do for other inputs to JSONStream.parse.
          return {path: [NEST0_OBJECT_KEY], value: data};
        }
      })
      .reduce({ inputXrefsById: {} }, function(acc, data) {
        const {value, path} = data;
        const valueKey = path.slice(-1)[0];
        if (!("valuesByKey" in acc)) {
          acc.valuesByKey = _.isFinite(valueKey) ? [] : {};
        }
        var valuesByKey = acc.valuesByKey;

        var entityKey = lastCommonKey !== true ? lastCommonKey : path.slice(-1)[0];

        var entityPathRelToValue = common.slice(JSONStreamPath.length)
          .map(s => s === true ? entityKey : s);
        var entity = getByParsedPath(
          value,
          entityPathRelToValue
        );
        /*
        console.warn('data');
        console.warn(data);
        console.warn('path');
        console.warn(path);
        console.warn('entityKey');
        console.warn(entityKey);
        console.warn('entityPathRelToValue');
        console.warn(entityPathRelToValue);
        console.warn('valueKey');
        console.warn(valueKey);
        console.warn('entity is plain object: ' + _.isPlainObject(entity));
        //*/
        var xrefDataSource = getByParsedPath(
          entity,
          relPathToXrefDataSourceParsed
        );
        var xrefIdentifier = getByParsedPath(
          entity,
           relPathToXrefIdentifierParsed
        );
        if (xrefDataSource && xrefIdentifier) {
          const entityPathRelToValuesByKey = [valueKey].concat(entityPathRelToValue);
          var xrefDataSourceAndIdentifier = [xrefDataSource, xrefIdentifier].join(":");
          if (acc.inputXrefsById[xrefDataSourceAndIdentifier]) {
            acc.inputXrefsById[xrefDataSourceAndIdentifier]
                .entityPaths.push(entityPathRelToValuesByKey);
          } else {
            acc.inputXrefsById[xrefDataSourceAndIdentifier] = {
              entityPaths: [entityPathRelToValuesByKey],
              xrefDataSource: xrefDataSource,
              xrefIdentifier: xrefIdentifier
            };
          }
        }
        valuesByKey[valueKey] = value;
        /*
        console.warn('value');
        console.warn(value);
        console.warn('valueKey');
        console.warn(valueKey);
        //*/
        return acc;
      })
      .flatMap(function(reducedData) {
        /*
        console.warn('reducedData');
        console.warn(JSON.stringify(reducedData, null, '  '));
        //*/
        var {inputXrefsById, valuesByKey} = reducedData;
        var inputXrefs = _.values(reducedData.inputXrefsById);
        var inputXrefDataSources = _.uniq(
          inputXrefs.map(function(inputXref) {
            return inputXref.xrefDataSource;
          })
        );

        const validInputXrefDataSources$ = hl(_.uniq(
          inputXrefs.map(function(inputXref) {
            return inputXref.xrefDataSource;
          })
        ))
          .flatMap(function(inputXrefDataSource) {
            return bridgeDb
              .identifyHeaderNameForXrefDataSource(inputXrefDataSource)
              .filter(function(inputXrefDataSourceType) {
                return inputXrefDataSourceType !== null;
              })
              .map(function(inputXrefDataSourceType) {
                return inputXrefDataSource;
              })
              .toNodeStream();
          })

        return validInputXrefDataSources$
          .collect()
          .flatMap(function(validInputXrefDataSources) {
            const validInputXrefs = inputXrefs.filter(({xrefDataSource}) => {
              return validInputXrefDataSources.indexOf(xrefDataSource) > -1;
            });

            if (validInputXrefs.length === 0) {
              console.warn("No valid input xrefs found.");
              return hl();
            }
            return bridgeDb
              .xrefsBatch(
                organism,
                validInputXrefs.map(({xrefDataSource}) => xrefDataSource),
                validInputXrefs.map(({xrefIdentifier}) => xrefIdentifier),
                desiredXrefDataSources
              )
              .map(function(xrefsResult) {
                /*
                console.warn('xrefsResult');
                console.warn(xrefsResult);
                //*/
                const {inputXrefDataSource, inputXrefIdentifier} = xrefsResult;
                xrefsResult.inputId = [
                  inputXrefDataSource,
                  inputXrefIdentifier
                ].join(":");
                return xrefsResult;
              })
              .filter(function(xrefsResult) {
                // TODO we can probably get rid of this. It's only here
                // b/c my dummy server returns incorrect xrefs.
                return xrefsResult.inputId in inputXrefsById;
              })
              .toArray()
              .toNodeStream()
              .map(function(xrefsResults) {
                /*
                 * Consider specifying the xref in entitiesById and
                          then adding the mappings to sameAs.
                 * Then for the SVG, we might only use "type" for class
                          but use type + mapped sameAs for typeof???
                  //*/

                xrefsResults.forEach(function(xrefsResult) {
                  var inputXrefId = xrefsResult.inputId;
                  /*
                      console.warn('xrefsResult');
                      console.warn(xrefsResult);
                      console.warn('valuesByKey');
                      console.warn(valuesByKey);
            //*/
            if (addLocally) {
              inputXrefsById[
                inputXrefId
              ].entityPaths.forEach(function(entityPath) {
                var entity = getByParsedPath(valuesByKey, entityPath);
                var whereToAdd = pathToInsertionPointParsed.slice(
                  common.length);
                var xrefContainer = getByParsedPath(entity, whereToAdd) || [];
                /*
                          console.warn('entity');
                          console.warn(entity);
                          console.warn('entityPath');
                          console.warn(entityPath);
                          console.warn('whereToAdd');
                          console.warn(whereToAdd);
                          console.warn('xrefContainer');
                          console.warn(xrefContainer);
        //*/

        var xrefMapping;
        if (!_.isArray(xrefContainer)) {
          xrefsResult.xrefs.map(function(xref) {
            var {xrefDataSource, xrefIdentifier} = xref;
            if (!(xrefDataSource in xrefContainer)) {
              xrefContainer[xrefDataSource] = xrefIdentifier;
            } else {
              const preexistingXrefDataSource = xrefContainer[xrefDataSource];
              if (_.isString(preexistingXrefDataSource)) {
                if (preexistingXrefDataSource !== xrefIdentifier) {
                  xrefContainer[xrefDataSource] = [
                    preexistingXrefDataSource,
                    xrefIdentifier
                  ];
                }
              } else if (_.isArray(preexistingXrefDataSource)) {
                if (preexistingXrefDataSource.indexOf(xrefIdentifier) === -1) {
                  xrefContainer[xrefDataSource].push(xrefIdentifier);
                }
              } else {
                console.warn(`
  Property ${xrefDataSource} already set at specified path, and
  it's not a string or array. Skipping addition of ${xrefIdentifier}.`);
                console.warn(JSON.stringify(entity));
              }
            }
          });
        } else {
          xrefsResult.xrefs.map(function(xref) {
            var mappedXref = [xref.xrefDataSource, xref.xrefIdentifier].join(":");
            if (xrefContainer.indexOf(mappedXref) === -1) {
              xrefContainer.push(mappedXref);
            }
          });
        }
                if (xrefContainer !== entity) {
                  _.set(entity, whereToAdd, xrefContainer);
                }
              });
            } else {
              var xrefMapping;
              var xrefMappingStarter = {
                closeMatch: []
              };
              if (!_.isArray(valuesByKey)) {
                if (!(inputXrefId in valuesByKey)) {
                  xrefMapping = valuesByKey[inputXrefId] =
                    xrefMappingStarter;
                } else {
                  xrefMapping = valuesByKey[inputXrefId];
                }
              } else {
                xrefMapping = _.find(
                  ({id}) => id === inputXrefId,
                  valuesByKey
                );
                if (!xrefMapping) {
                  xrefMapping = xrefMappingStarter;
                  valuesByKey.push(xrefMapping);
                }
              }

              if (!("id" in xrefMapping)) {
                xrefMapping.id = inputXrefId;
              }

              if (!("closeMatch" in xrefMapping)) {
                xrefMapping.closeMatch = [];
              }
              var closeMatch = xrefMapping.closeMatch;
              xrefsResult.xrefs.map(function(xref) {
                var mappedXref = [xref.xrefDataSource, xref.xrefIdentifier].join(":");
                if (closeMatch.indexOf(mappedXref) === -1) {
                  closeMatch.push(mappedXref);
                }
              });
            }
                });

                return {
                  event: "data",
                  path: JSONStreamParentPath,
                  value: NEST0_OBJECT_KEY in valuesByKey
                  ?
                  valuesByKey[NEST0_OBJECT_KEY]
                  :
                  valuesByKey
                };
              });
          });
      });

    process.stdin.pipe(containerParser);

    endStream.each(function() {
      headerStream.write(hl.nil);
      dataStream.write(hl.nil);
      footerStream.write(hl.nil);
      /*
      headerStream.end();
      dataStream.end();
      footerStream.end();
      //*/
    });

    var stringifier;
    var i = 0;
    return hl([headerStream, parsedDataStream, footerStream])
      .merge()
      .reduce({}, function(acc, result) {
        var {path, value, event} = result;
        /*
        console.warn('result');
        console.warn(result);
        //*/
        if (_.isArray(value)) {
          if (i === 0) {
            stringifier = JSONStream.stringify();
            if (_.isEmpty(path)) {
              acc = [];
            }
          }
          if (_.isEmpty(path)) {
            value.forEach(function(v) {
              acc.push(v);
            });
          } else {
            _.updateWith(
              acc,
              path,
              (nsValue) => typeof nsValue === 'undefined'
                ?
                value
                :
                _.isArray(nsValue) ? nsValue.concat(value) : _.assign(nsValue, value),
              (nsValue, key, nsObject) => nsValue || _.isFinite(parseInt(key)) ? Array : Object
            );
          }
        } else {
          if (i === 0) {
            stringifier = JSONStream.stringify(false);
            //stringifier = JSONStream.stringifyObject();
          }
          if (_.isEmpty(path)) {
            acc = _.assign(acc, value);
          } else {
            _.updateWith(
              acc,
              path,
              (nsValue) => _.isArray(nsValue) ? nsValue.concat(value) : _.assign(nsValue, value),
              (nsValue, key, nsObject) => nsValue || _.isFinite(key) ? [] : {}
            );
          }
        }
        i += 1;
        return acc;
      })
      .flatMap(function(s) {
        return hl(_.isArray(s) ? s : [s])
          .through(stringifier);
      })
      .pipe(process.stdout);
  })
  .on("--help", function() {
    console.log(`
  Add alternate xrefs (datasource identifiers) to your JSON.

  For example, if your JSON looks like this:
  {
    "id": "abc123",
    "xref": {
      "dataSource": "ensembl",
      "identifier": "ENSG00000132031"
    }
  }

  you can get back something like this:
  {
    "id": "abc123",
    "xref": {
      "dataSource": "ensembl",
      "identifier": "ENSG00000132031",
      "alternates": ["ncbigene:4148", "uniprot:O15232"]
    }
  }

  When you pipe your JSON though this tool, it will:
  1) find the xref(s) in your JSON as specified by
     pathToXrefDataSource and pathToXrefIdentifier
  1) map the found xrefs to equivalents/alternates from
     other datasources. If you specified one or more
     desiredDataSource(s), the mapped xrefs will be
     limited to what you specified.
  2) add these mapped xrefs to your JSON at the location(s)
     specified by pathToInsertionPoint
  3) pipe your JSON back out with the added xrefs

  Paths use the format of basic jq filters, e.g.:
        .a
        .a.z
        .a.z.x
        .a.z.x.y
        .[]
        .[].z
        .[].z.y
        .[].z.y.x
        .a[]
        .a[].z
        .a[].z.y
        .a[].z.y.x

    More info: https://stedolan.github.io/jq/manual/v1.5/#Basicfilters

  Examples:

    echo '{"id":"abc123","xref":{"dataSource":"ensembl","identifier":"ENSG00000132031"}}' |\\
    bridgedb addAlternateXrefs \\
      Human \\
      ".xref.dataSource" \\
      ".xref.identifier" \\
      ".xref.alternates" \\
      ensembl uniprot

    echo '[{"xrefDataSource": "Entrez Gene", "xrefIdentifier": "1234"}]' |\\
    bridgedb addAlternateXrefs \\
      Human \\
      ".[].xrefDataSource" \\
      ".[].xrefIdentifier" \\
      ".[]" \\
      ensembl ncbigene uniprot wikidata

    For developers:

    cat ./test/inputs/nest0-array.json |\\
    ./bin/bridgedb addAlternateXrefs \\
      Human \\
      ".[].xrefDataSource" \\
      ".[].xrefIdentifier" \\
      ".[].type" \\
      ensembl ncbigene uniprot wikidata |\\
    jq .

    cat ./test/inputs/nest0-array.json |\\
    ./bin/bridgedb addAlternateXrefs Human \\
      ".[].xrefDataSource" ".[].xrefIdentifier" \\
      ".[]" \\
      ensembl ncbigene uniprot wikidata |\\
    jq .

    cat ./test/inputs/nest1-object.json |\\
    ./bin/bridgedb addAlternateXrefs Human \\
      ".entitiesById[].xrefDataSource" ".entitiesById[].xrefIdentifier" \\
      ".entitiesById[].type" \\
      ensembl ncbigene uniprot wikidata |\\
    jq .

    cat ./test/inputs/nest1-object.json |\\
    ./bin/bridgedb addAlternateXrefs Human \\
      ".entitiesById[].xrefDataSource" ".entitiesById[].xrefIdentifier" \\
      ".entitiesById" \\
      ensembl ncbigene uniprot wikidata |\\
    jq .

  Note: This has been tested on the pvjson format from gpml2pvjson:
    <https://github.com/wikipathways/gpml2json>
    If you are using it on another format, exercise caution and verify your results.
      
    `);
  });

/*
echo '[{"xrefIdentifier": "1234", "xrefDataSource": "Entrez Gene"},'\
    '{"xrefIdentifier": "1235", "xrefDataSource": "Entrez Gene"}]' |\
  jq -rc .[] |\
  ./bin/bridgedb enrichBatch " Homo sapiens" xrefDataSource xrefIdentifier

cat data.txt | jq -rc . | bin/bridgedb enrichBatch "Homo sapiens" xrefDataSource xrefIdentifier

echo '[{"xrefIdentifier": "1234", "xrefDataSource": "Entrez Gene"},'\
    '{"xrefIdentifier": "1235", "xrefDataSource": "Entrez Gene"}]' |\
  jq -rc .[] |\
  ./bin/bridgedb enrich "Homo sapiens" xrefDataSource xrefIdentifier ncbigene ensembl wikidata
//*/

program
  .command("xrefs <organism> <xrefDataSource> <xrefIdentifier>")
  .action(function(organism, xrefDataSource, xrefIdentifier) {
    var serialize = ndjson.serialize();
    var bridgeDb = new BridgeDb();
    bridgeDb
      .xrefs(organism, xrefDataSource, xrefIdentifier)
      .subscribe(xrefsResponseQueue)
      .throughNodeStream(serialize)
      .pipeToStdout();
  })
  .on("--help", function() {
    console.log(`
  Examples:

      bridgedb xrefs 'Homo sapiens' 'Entrez Gene' '1234'

    For developers:
      npm run compile:es5 && ./bin/bridgedb xrefs 'Homo sapiens' 'Entrez Gene' '1234'

      cat test/xrefDataSourcesAndIdentifiers.csv |\\
      while read ln; do \\
        xrefDb=\${echo $ln | sed s/,.*//g}; \\
        xrefId=\${echo $ln | sed 's/^.*,//g'}; \\
        echo "$xrefDb" "$xrefId"; \\
        ./bin/bridgedb xrefs "Homo sapiens" "$xrefDb" "$xrefId"; \\
      done

      cat test/xrefDataSourcesAndIdentifiers.csv |\
      while read ln; do \\
        xrefDb=\${echo $ln | sed s/,.*//g}; \\
        xrefId=\${echo $ln | sed 's/^.*,//g'}; \\
        echo "$xrefDb" "$xrefId"; \\
        ./bin/bridgedb xrefs "Homo sapiens" "$xrefDb" "$xrefId" |\\
        jq ". | .xrefIdentifier | {\"$xrefId\": .}" |\\
        tee $xrefId.tsv & \\
      done
    `);
  });

program
  .command("datasource <input> [as]")
  .option(
    "--format [string]",
    `Return format: name or iri. Default: "name"`
  )
  .action(function(input, as, options) {
    var format = !!options["format"] ? options["format"] : "name";
    var serialize = ndjson.serialize();
    var bridgeDb = new BridgeDb();
    if (!!as) {
      bridgeDb
        .convertXrefDataSourceTo(as, input)
        .throughNodeStream(serialize)
        .pipeToStdout();
    } else {
      if (format === "name") {
        bridgeDb
          .identifyHeaderNameForXrefDataSource(input)
          .throughNodeStream(serialize)
          .pipeToStdout();
      } else {
        bridgeDb
          .dataSourceNameToColumnIri(input)
          .throughNodeStream(serialize)
          .pipeToStdout();
      }
    }
  })
  .on("--help", function() {
    console.log(`
  Identify the format of a given xref data source.

  Examples:

    For developers:
      npm run compile:es5 && ./bin/bridgedb dataSource 'Entrez Gene'

      npm run compile:es5 && ./bin/bridgedb dataSource 'Entrez Gene'

      cat ../gpml2pvjson-js/test/expected/WP481_94171.json |\\
      jq '.entitiesById[] |'\\
        ' select(has("xrefDataSource") and .kaavioType=="SingleFreeNode") |'\\
        ' .xrefDataSource+"\t"+.xrefIdentifier'
    `);
  });

program
  .command(
    "xrefsBatch [xrefIdentifierColumn] [xrefDataSourceColumn] [organismColumn]"
  )
  .description("Get xrefs for entities in a delimited file (CSV, TSV, etc.)")
  .option(
    "--xrefDataSource [string]",
    'If xrefDataSourceColumn not specified, set xrefDataSource, e.g., "Entrez Gene"'
  )
  .option(
    "--organism [string]",
    'If organismColumn not specified, set organism, e.g., "Homo sapiens"'
  )
  .option(
    "--desiredXrefDataSources [string]",
    `Limit results to specified desiredXrefDataSource(s).
    If specifying multiple, separate with a comma.`
  )
  .option("--headers [boolean]", "Does first row of input file contain headers?")
  .option(
    "-d, --delimiter [string]",
    'Delimiter for file, e.g., "," or "\\t". Default: "\\t"'
  )
  .option(
    "-n, --newline [string]",
    'New line character for file, e.g., "\\n" or "\\r\\n". Default: "\\n"'
    // (use \r\n for CRLF files)
  )
  .option(
    "-q, --quote [string]",
    `Quote character for file, e.g., '"'. Default: '"'`
  )
  .option(
    "-c, --comment [string]",
    `Comment character for file, e.g., "#" or "''". Default: '#'`
  )
  .action(function(
    xrefIdentifierColumnStr,
    xrefDataSourceColumnStr,
    organismColumnStr,
    options
  ) {
    var organismOption = options.organism;
    var xrefDataSourceOption = options.xrefDataSource;
    var desiredXrefDataSources = !!options.desiredXrefDataSources
      ? options.desiredXrefDataSources.split(",")
      : undefined;
    var headersOption = options.hasOwnProperty("headers")
      ? Boolean(options.headers)
      : false;
    var delimiterOption = options.delimiter || "\t";
    var newlineOption = options.newline || "\n";
    var quoteOption = options.quote || '"';
    var commentOption = options.comment || '#';

    var organismColumn = typeof organismColumnStr !== "undefined"
      ? parseInt(organismColumnStr)
      : typeof organismOption === "undefined" ? 0 : null;

    var xrefDataSourceColumn = typeof xrefDataSourceColumnStr !==
      "undefined"
      ? parseInt(xrefDataSourceColumnStr)
      : typeof xrefDataSourceOption === "undefined"
        ? organismColumn === null ? 0 : organismColumn + 1
        : null;

    var xrefIdentifierColumn = typeof xrefIdentifierColumnStr !== "undefined"
      ? parseInt(xrefIdentifierColumnStr)
      : typeof xrefIdentifierOption === "undefined"
        ? xrefDataSourceColumn === null ? 0 : xrefDataSourceColumn + 1
        : null;

    var bridgeDb = new BridgeDb();

    var parser = csv({
      delimiter: delimiterOption,
      newline: newlineOption,
      quote: quoteOption,
      objectMode: true
    });

    var commentLineRe = new RegExp(`^${commentOption}.*$[${newlineOption}]?`, "gm");
    Rx.Observable
      .fromNodeReadableStream(
        hl(process.stdin)
        // Ignore comments
        .through(replaceStream(commentLineRe, ""))
        .through(parser).drop(headersOption ? 1 : 0)
      )
      .map(function(row) {
        return {
          organism: typeof organismOption !== "undefined"
            ? organismOption
            : row[organismColumn],
          xrefDataSource: typeof xrefDataSourceOption !== "undefined"
            ? xrefDataSourceOption
            : row[xrefDataSourceColumn],
          xrefIdentifier: typeof xrefIdentifierOption !== "undefined"
            ?
              xrefIdentifierOption
            :
              row[xrefIdentifierColumn]
        };
      })
      /* TODO should we use this?
      .distinctUntilChanged(function(
        a,
        b
      ) {
        return (
          [a.xrefDataSource, a.xrefIdentifier].join() ===
          [b.xrefDataSource, b.xrefIdentifier].join()
        );
        //return JSON.stringify(a) === JSON.stringify(b);
      })
	    //*/
      .mergeMap(function({organism, xrefDataSource, xrefIdentifier}) {
        return bridgeDb
          .xrefs(organism, xrefDataSource, xrefIdentifier, desiredXrefDataSources)
      })
      /* wide format
      .map(function(result) {
        const firstColumn = typeof xrefDataSourceOption !== "undefined"
          ? result.inputXrefIdentifier
          : [result.inputXrefDataSource, result.inputXrefIdentifier].join(":");
        
        //console.warn(`Results for ${firstColumn}`);
        return (
          [
            firstColumn,
            '"' + result.xrefs
              .map(function(xref) {
                return [xref.xrefDataSource, xref.xrefIdentifier].join(":");
              })
              .join(delimiterOption) + '"'
          ].join(delimiterOption)
        );
      })
      //*/
      //* long format
      .mergeMap(function(result) {
        const firstColumn = typeof xrefDataSourceOption !== "undefined"
          ? result.inputXrefIdentifier
          : [result.inputXrefDataSource, result.inputXrefIdentifier].join(delimiterOption);
        //console.warn(`Results for ${firstColumn}`);
        return Rx.Observable.from(result.xrefs)
        .map(xref => {
          return [
            firstColumn,
            [xref.xrefDataSource, xref.xrefIdentifier].join(delimiterOption)
          ].join(delimiterOption)
        });
      })
      .map(line => line + newlineOption)
      .pipeToStdout();
  })
  .on("--help", function() {
    console.log(`
  Examples:

    bridgedb xrefsBatch --organism 'Homo sapiens' --xrefDataSource 'Entrez Gene' \\
    < $'1234\n1235\n'

    For developers:
      Compile, if needed:
      npm run compile:es5

      Run it, as in one of the following examples:

      echo $'1234\n1235\n' |\\
      ./bin/bridgedb xrefsBatch --organism 'Homo sapiens' --xrefDataSource 'Entrez Gene'

      ./bin/bridgedb xrefsBatch --organism 'Homo sapiens' --xrefDataSource 'Entrez Gene' \\
      <<< $'1234\n1235\n'

      echo $'xrefIdentifier\n1234\n1235\n' |\\
      ./bin/bridgedb xrefsBatch --organism 'Homo sapiens' --xrefDataSource \\
        'Entrez Gene' --headers=true

      cat test/xrefIdentifiers.csv |\\
      ./bin/bridgedb xrefsBatch --organism="Homo sapiens" --xrefDataSource="Entrez Gene"

      ./bin/bridgedb xrefsBatch --organism="Homo sapiens" < test/xrefDataSourcesAndIdentifiers.csv

      cat test/xrefDataSourcesAndIdentifiers.csv | \\
        ./bin/bridgedb xrefsBatch --organism="Homo sapiens"
    `);
  });

program
  .command('*')
  .action(function(cmd){
    console.error("");
    console.error('\ \ Unrecognized command "%s". Valid commands shown below:', cmd);
    program.outputHelp();
  });

program.parse(process.argv);

// If no command is specified, output help.
if (!process.argv.slice(2).length) {
  program.outputHelp();
}
