#!/usr/bin/env node

var _ = require("lodash");
var crypto = require("crypto");
var csv = require("csv-streamify");
var fs = require("fs");
var jsonpath = require('jsonpath');
var path = require("path");
var BridgeDb = require("../es5/BridgeDb").BridgeDb;
var hl = require("highland");
var ndjson = require("ndjson");
var JSONStream = require("JSONStream");
var npmPackage = require("../package.json");
var program = require("commander");
var Rx = require("rx-extra");
require("../es5/spinoffs/pipeToStdout");
require("../es5/spinoffs/toNodeStream");
var VError = require("verror");

program
  .version(npmPackage.version)
  .description("CLI client for BridgeDb ID mapping webservice.");

program.on("--help", function() {
  console.log("  Examples:");
  console.log();
  console.log("    Display xrefs in command line:");
  console.log("    $ bridgedb xrefs 'Homo sapiens' 'Entrez Gene' 1234");
  console.log();
  console.log("    Save multiple xrefs to new file:");
  console.log(
    [
      "    $ cat test/dbNamesAndIds.csv | bridgedb xrefsBatch ",
      "--organism='Homo sapiens' > ./xrefs.json"
    ].join("")
    /* TODO why doesn't the following work?
    [
      "    $ bridgedb xrefsBatch ",
      "--organism='Homo sapiens' --xrefDataSourceNS='Entrez Gene' ",
      "< ./test/dbNamesAndIds.csv > ./xrefs.json"
    ].join("")
    //*/
  );
});

// path options
// https://www.npmjs.com/package/node-red-contrib-json
// JSONata: https://github.com/jsonata-js/jsonata/blob/master/tutorial.md
// JSON Path: http://goessner.net/articles/JsonPath/
// jq
// ...

function jsonPathToLodashPath(jsonPath) {
  const jsonPathParsed = parseJsonPath(jsonPath);
  const unhandledOperators = _.intersection(jsonPathParsed, ["..", "*"]);
  if (unhandledOperators.length > 0) {
    throw new Error(`Cannot currently handle ${unhandledOperators.join()} operator(s).`);
  }
  return jsonPathParsed.filter(s => s !== "$").map(s => s === true ? "*" : s).join(".");
}

function serializeJsonPath(pathComponents) {
  const unhandledOperators = _.intersection(pathComponents, [".."]);
  if (unhandledOperators.length > 0) {
    throw new Error(`Cannot currently handle ${unhandledOperators.join()} operator(s).`);
  }
  return pathComponents.map(s => s === true ? "*" : s).join(".");
}

function parseJsonPath(path) {
  if (path.indexOf("..") > -1) {
    throw new Error('Cannot currently handle ".." operator.');
  }
  return path.split(".").map(s => s === "*" ? true : s);
}

/************
 * jq
 **********/

function jqToJSONStreamPath(jqPath) {
  const jqPathParsed = parseJQPath(jqPath);
  const unhandledOperators = _.intersection(jqPathParsed, [".."]);
  if (unhandledOperators.length > 0) {
    throw new Error(`Cannot currently handle ${unhandledOperators.join()} operator(s).`);
  }
  return jqPathParsed.map(s => s === true ? "*" : s).join(".");
}

function jqPathToLodashParsedPath(jqPath) {
  const jqPathParsed = parseJQPath(jqPath);
  const unhandledOperators = _.intersection(jqPathParsed, ["..", true]);
  if (unhandledOperators.length > 0) {
    throw new Error(`Cannot currently handle ${unhandledOperators.join()} operator(s).`);
  }
  return jqPathParsed;
}

/*
function serializeJQPath(pathComponents) {
  const unhandledOperators = _.intersection(pathComponents, [".."]);
  if (unhandledOperators.length > 0) {
    throw new Error(`Cannot currently handle ${unhandledOperators.join()} operator(s).`);
  }
  return pathComponents.map(s => s === true ? "*" : s).join(".");
}
//*/

function parseJQPath(path) {
  return path.replace(/^\./, "")
    .split(".")
    .reduce((acc, s) => {
      (s.match(/(\w+)(\[\w*\])?/) || [])
        .slice(1)
        .filter(_.negate(_.isUndefined))
        .map(s => s === "[]" ? true : s.replace(/\[(\w+)\]/, "\1"))
        //.map(s => s.replace(/\[(\w+)\]/, "\1").replace(/\[\]/, true))
        .forEach(function(s) {
          acc.push(s);
        });
      return acc;
    }, []);
}

function resolveJQPath(base, relativePath) {
  if (base.endsWith(".") && relativePath.startsWith(".")) {
    return base + relativePath.replace(/^\./, "");
  } else if (base.endsWith(".") || relativePath.startsWith(".")) {
    return base + relativePath;
  } else {
    return base + "." + relativePath;
  }
}

/* Similar to HTML base element
 * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base
 * and xml:base
 * https://www.w3.org/TR/xmlbase/
 */
const DEFAULT_ADDMAPPEDXREFS_BASE = ".";
//const DEFAULT_ADDMAPPEDXREFS_BASE = "$";
program
  .command(
    `addMappedXrefs <organism> <pathToXrefNS> <pathToXrefID>\\
    <pathToAddMappedXrefs> [mapToXrefNS...]`
  )
  .option(
    "-b,--base [path]",
    `jq expression that is prepended to all other paths.
    Default: "${DEFAULT_ADDMAPPEDXREFS_BASE}"`,
    (base) => !!base ? base : DEFAULT_ADDMAPPEDXREFS_BASE
  )
  .action(function(
    organism,
    pathToXrefNS,
    pathToXrefID,
    pathToAddMappedXrefs,
    mapToXrefNSes,
    optionsRaw
  ) {
    /*
    var bridgeDb = new BridgeDb();
    //*/
    //*
    var bridgeDb = new BridgeDb({
      baseIri: "http://localhost:4522/",
      dataSourcesHeadersIri: "http://localhost:4522/datasources_headers.txt",
      dataSourcesMetadataIri: "http://localhost:4522/datasources.txt"
    });
    //*/

    const options = _.defaults(optionsRaw, {
      base: DEFAULT_ADDMAPPEDXREFS_BASE
    });
    var base = options.base;

    var {common, sub} = _.zip
      .apply(
        undefined,
        [pathToXrefNS, pathToXrefID].map(p => resolveJQPath(base, p)).map(parseJQPath)
      )
      .reduce(
        function(acc, pair) {
          const [first, second] = pair;
          acc.matched = acc.matched && first === second;
          if (acc.matched) {
            acc.common.push(first);
          } else {
            pair.forEach(function(p, i) {
              if (acc.sub[i]) {
                acc.sub[i].push(p);
              } else {
                acc.sub[i] = [p];
              }
            });
          }
          return acc;
        },
        { matched: true, common: [], sub: [] }
      );
    const [relPathToXrefDataSourceNSParsed, relPathToXrefDataSourceIDParsed] = sub;

    if (_.intersection(_.uniq(sub), [true]).length > 0) {
      throw new Error(`There must only be one xrefNS per xrefID, but
      provided paths may violate that constraint.`);
    }

    const pathToAddMappedXrefsParsed = parseJQPath(resolveJQPath(base, pathToAddMappedXrefs));
    var addLocally;
    if (pathToAddMappedXrefsParsed.indexOf(true) > -1) {
      if (serializeJsonPath(pathToAddMappedXrefsParsed.slice(0, -1)) ===
          serializeJsonPath(common)) {
        addLocally = true;
      } else {
        addLocally = false;
      }
    } else {
      addLocally = false;
    }

    var jsonStreamPath = common;
    var wildcardCount = common.filter(p => p === true).length;
    if (wildcardCount > 0) {
      if (wildcardCount > 1) {
        throw new Error(`Not currently able to parse more than one wildcard.`);
      } else if (common.slice(-1)[0] === true) {
        jsonStreamPath[jsonStreamPath.length - 1] = {emitPath: true};
      } else {
        throw new Error(`Not currently able to parse wildcard at different locations
          for xrefNS and xrefID.`);
      }
    }
    var containerParser = JSONStream.parse(jsonStreamPath);

    var headerStream = hl("header", containerParser).map(function(header) {
      return _.toPairs(header)[0];
    });

    var key = common[0];
    var parentKey = common[0];

    var dataStream = hl("data", containerParser);

    var footerStream = hl("footer", containerParser).map(function(footer) {
      return _.toPairs(footer)[0];
    });

    var endStream = hl("end", containerParser);

    var parsedDataStream = dataStream
      .reduce({ inputXrefsById: {} }, function(acc, data) {
        var entity = data.value;
        var entityPath = data.path;
        var entityKey = entityPath.slice(-1)[0];

        if (!("entitiesByKey" in acc)) {
          var accIsArray = _.isFinite(entityKey);
          acc.entitiesByKey = accIsArray ? [] : {};
          acc.parentKey = entityPath.length > 1
            ?
              entityPath.slice(-2)[0]
            :
              null;
        }

        var xrefNS = _.get(
          entity,
          relPathToXrefDataSourceNSParsed
        );
        var xrefID = _.get(
          entity,
          relPathToXrefDataSourceIDParsed
        );
        if (xrefNS && xrefID) {
          var xrefNSAndID = [xrefNS, xrefID].join(":");
          if (acc.inputXrefsById[xrefNSAndID]) {
            acc.inputXrefsById[xrefNSAndID].entityKeys.push(entityKey);
          } else {
            acc.inputXrefsById[xrefNSAndID] = {
              entityKeys: [entityKey],
              NS: xrefNS,
              ID: xrefID
            };
          }
        }
        acc.entitiesByKey[entityKey] = entity;
        return acc;
      })
      .flatMap(function(reducedData) {
        /*
        console.warn('reducedData');
        console.warn(reducedData);
        //*/
        var inputXrefs = _.values(reducedData.inputXrefsById);
        var inputXrefNSes = _.uniq(
          inputXrefs.map(function(inputXref) {
            return inputXref.NS;
          })
        );

        var xrefNSFormatter$;
        if (!!mapToXrefNSes) {
          xrefNSFormatter$ = hl([mapToXrefNSes[0]])
            .flatMap(function(mapToXrefNS) {
              return bridgeDb
                .dataSourceNameToColumnTerm(mapToXrefNS)
                .first()
                .map(function(mapToXrefNSType) {
                  return bridgeDb.convertDataSourceNameTo(mapToXrefNSType);
                })
                .toNodeStream()
            });
        } else {
          xrefNSFormatter$ = hl([Rx.Observable.of])
        }

        return xrefNSFormatter$
          .flatMap(function(xrefNSFormatter) {
            return hl(inputXrefNSes)
              .flatMap(function(inputXrefNS) {
                return bridgeDb
                  .dataSourceNameToColumnTerm(inputXrefNS)
                  .filter(function(inputXrefNSType) {
                    return inputXrefNSType !== null;
                  })
                  .map(function(inputXrefNSType) {
                    return {inputXrefNS, inputXrefNSType};
                  })
                  .toNodeStream();
              })
              .flatMap(function({inputXrefNS, inputXrefNSType}) {
                return hl(
                  inputXrefs.filter(function(inputXref) {
                    return inputXref.NS === inputXrefNS;
                  })
                  .map(function(inputXref) {
                    inputXref.NSType = inputXrefNSType;
                    return inputXref;
                  })
                );
              })
              .collect()
              .flatMap(function(inputXrefs) {
                if (inputXrefs.length === 0) {
                  console.warn("No valid input xrefs found.");
                  return hl();
                }
                return bridgeDb
                  .xrefsBatch(
                    organism,
                    inputXrefs.map(({NS}) => NS),
                    inputXrefs.map(({ID}) => ID)
                    //dataSourceFilter?: string
                  )
                  .mergeMap(function(xrefsResult) {
                    return Rx.Observable.from(xrefsResult.xrefs)
                      .mergeMap(function(xref) {
                        return xrefNSFormatter(xref.dataSource)
                          .filter(xrefNS => !mapToXrefNSes ||
                            mapToXrefNSes.indexOf(xrefNS) > -1)
                          .map(function(xrefNS) {
                            return {
                              NS: xrefNS,
                              ID: xref.dbId
                            };
                          });
                      })
                      .toArray()
                      .map(function(xrefs) {
                        xrefsResult.xrefs = xrefs;
                        return xrefsResult;
                        /*
                            return {
                              xrefs,
                              ...xrefResult
                            };
                            return {
                              organism: xrefResult.organism,
                              inputDataSource: xrefResult.inputDataSource,
                              inputDbId: xrefResult.inputDbId,
                              xrefs: xrefs
                            };
                        //*/
                      });
                  })
                  .toArray()
                  .toNodeStream()
                  .map(function(xrefsResults) {
                    /*
                        TODO continue approx. here...
                     * Consider specifying the xref in entitiesById and
                          then adding the mappings to sameAs.
                     * Then for the SVG, we might only use "type" for class
                          but use type + mapped sameAs for typeof???
                      //*/
                    var parentKey = reducedData.parentKey;
                    xrefsResults.forEach(function(xrefsResult) {
                      var inputXrefId = [
                        xrefsResult.inputDataSource,
                        xrefsResult.inputDbId
                      ].join(":");
                      if (addLocally) {
                        reducedData.inputXrefsById[
                          inputXrefId
                        ].entityKeys.forEach(function(entityKey) {
                          var entity = reducedData.entitiesByKey[entityKey];
                          xrefsResult.xrefs.map(function(xref) {
                            var mappedXref = [xref.NS, xref.ID].join(":");
                            if (entity.type.indexOf(mappedXref) === -1) {
                              entity.type.push(mappedXref);
                            }
                          });
                        });
                      } else {
                        var xrefMapping;
                        var xrefMappingStarter = {
                          closeMatch: []
                        };
                        if (!!parentKey) {
                          if (!(inputXrefId in reducedData.entitiesByKey)) {
                            xrefMapping = reducedData.entitiesByKey[inputXrefId] =
                              xrefMappingStarter;
                          } else {
                            xrefMapping = reducedData.entitiesByKey[inputXrefId];
                          }
                        } else {
                          xrefMapping = _.find(
                            ({id}) => id === inputXrefId,
                            reducedData.entitiesByKey
                          );
                          if (!xrefMapping) {
                            xrefMapping = xrefMappingStarter;
                            reducedData.entitiesByKey.push(xrefMapping);
                          }
                        }

                        if (!("id" in xrefMapping)) {
                          xrefMapping.id = inputXrefId;
                        }

                        if (!("closeMatch" in xrefMapping)) {
                          xrefMapping.closeMatch = [];
                        }
                        var closeMatch = xrefMapping.closeMatch;
                        xrefsResult.xrefs.map(function(xref) {
                          var mappedXref = [xref.NS, xref.ID].join(":");
                          if (closeMatch.indexOf(mappedXref) === -1) {
                            closeMatch.push(mappedXref);
                          }
                        });
                      }
                    });
                    return {
                      entitiesByKey: reducedData.entitiesByKey,
                      parentKey: parentKey
                    };
                  });
              });
          });
      });
//      .map(function(data) {
//        var composedData;
//        if (subKeys.length === 0) {
//          composedData = data;
//        } else {
//          throw new Error("Don't know how to handle case of deeply nested entities.");
//          /*
//          console.warn("This hasn't been tested and may not work!");
//          composedData = subKeys.reverse().reduce(function(acc, p, i, x) {
//            if (i < x.length - 1) {
//              acc[p] = {};
//            } else {
//              acc[p] = data;
//            }
//            return acc;
//          }, [key, {}]);
//          //*/
//        }
//        return [key, composedData];
//      });

    process.stdin.pipe(containerParser);

    endStream.each(function() {
      headerStream.write(hl.nil);
      dataStream.write(hl.nil);
      footerStream.write(hl.nil);
      /*
      headerStream.end();
      dataStream.end();
      footerStream.end();
      //*/
    });

    return hl([headerStream, parsedDataStream, footerStream]).zipAll0()
      .flatMap(function([header, data, footer]) {
        const {parentKey, entitiesByKey} = data;
        if (!!parentKey) {
          return hl([header, footer])
            .reduce({[parentKey]: entitiesByKey}, function(acc, item) {
              acc[item[0]] = item[1];
              return acc;
            })
            .through(JSONStream.stringify(false))
        } else {
          return hl(entitiesByKey)
            .through(JSONStream.stringify())
        }
      })
      .pipe(process.stdout);
  })
  .on("--help", function() {
    console.log(`
  This has been tested on the pvjson format from gpml2pvjson:
    <https://github.com/wikipathways/gpml2json>
    If you are using it on another format, exercise caution and verify your results.
      
  Paths are in JSON Path format: <http://goessner.net/articles/JsonPath/>

  Examples:

    echo '[{"dbConventionalName": "Entrez Gene", "dbId": "1234"}]' |\\
    bridgedb addMappedXrefs Human \\
      "*.dbConventionalName" "*.dbId" \\
      "*.type" \\
      ensembl ncbigene uniprot wikidata |\\
    jq .

    For developers:

    cat input-array.json |\\
    ./bin/bridgedb addMappedXrefs Human \\
      "*.dbConventionalName" "*.dbId" \\
      "*.type" \\
      ensembl ncbigene uniprot wikidata |\\
    jq .

    cat input-array.json |\\
    ./bin/bridgedb addMappedXrefs Human \\
      "*.dbConventionalName" "*.dbId" \\
      "*" \\
      ensembl ncbigene uniprot wikidata |\\
    jq .

    cat input.json |\\
    ./bin/bridgedb addMappedXrefs Human \\
      "entitiesById.*.dbConventionalName" "entitiesById.*.dbId" \\
      "entitiesById.*.type" \\
      ensembl ncbigene uniprot wikidata |\\
    jq .

    cat input.json |\\
    ./bin/bridgedb addMappedXrefs Human \\
      "entitiesById.*.dbConventionalName" "entitiesById.*.dbId" \\
      "entitiesById" \\
      ensembl ncbigene uniprot wikidata |\\
    jq .
    `);
  });

/*
echo '[{"dbId": "1234", "xrefDataSourceNS": "Entrez Gene"},'\
    '{"dbId": "1235", "xrefDataSourceNS": "Entrez Gene"}]' |\
  jq -rc .[] |\
  ./bin/bridgedb enrichBatch " Homo sapiens" xrefDataSourceNS dbId

cat data.txt | jq -rc . | bin/bridgedb enrichBatch "Homo sapiens" xrefDataSourceNS dbId

echo '[{"dbId": "1234", "xrefDataSourceNS": "Entrez Gene"},'\
    '{"dbId": "1235", "xrefDataSourceNS": "Entrez Gene"}]' |\
  jq -rc .[] |\
  ./bin/bridgedb enrich "Homo sapiens" xrefDataSourceNS dbId ncbigene ensembl wikidata
//*/

program
  .command("xrefs <organism> <dbConventionalName> <dbId>")
  .action(function(organism, dbConventionalName, dbId) {
    var serialize = ndjson.serialize();
    var bridgeDb = new BridgeDb();
    bridgeDb
      .xrefs(organism, dbConventionalName, dbId)
      .subscribe(xrefsResponseQueue)
      .throughNodeStream(serialize)
      .pipeToStdout();
  })
  .on("--help", function() {
    console.log(`
  Examples:
    cat input.json |\
      ./bin/bridgedb addMapppedXrefs Human "entitiesById.*.dbConventionalName"\
        "entitiesById.*.dbId" "type" ensembl |\
      jq .

    For developers:
      npm run compile:es5 && ./bin/bridgedb xrefs 'Homo sapiens' 'Entrez Gene' '1234'

      cat test/dbNamesAndIds.csv |\\
      while read ln; do \\
        xrefDb=\${echo $ln | sed s/,.*//g}; \\
        xrefId=\${echo $ln | sed 's/^.*,//g'}; \\
        echo "$xrefDb" "$xrefId"; \\
        ./bin/bridgedb xrefs "Homo sapiens" "$xrefDb" "$xrefId"; \\
      done

      cat test/dbNamesAndIds.csv |\
      while read ln; do \\
        xrefDb=\${echo $ln | sed s/,.*//g}; \\
        xrefId=\${echo $ln | sed 's/^.*,//g'}; \\
        echo "$xrefDb" "$xrefId"; \\
        ./bin/bridgedb xrefs "Homo sapiens" "$xrefDb" "$xrefId" |\\
        jq ". | .dbId | {\"$xrefId\": .}" |\\
        tee $xrefId.tsv & \\
      done
    `);
  });

program
  .command("datasource <input> [as]")
  .option(
    "--format [string]",
    `Column format to return when identifying a data source name format: term or iri.
    Default: "term"`
  )
  .action(function(input, as, options) {
    var format = !!options["format"] ? options["format"] : "term";
    var serialize = ndjson.serialize();
    var bridgeDb = new BridgeDb();
    if (!!as) {
      bridgeDb
        .convertDataSourceNameTo(as, input)
        .throughNodeStream(serialize)
        .pipeToStdout();
    } else {
      if (format === "term") {
        bridgeDb
          .dataSourceNameToColumnTerm(input)
          .throughNodeStream(serialize)
          .pipeToStdout();
      } else {
        bridgeDb
          .dataSourceNameToColumnIri(input)
          .throughNodeStream(serialize)
          .pipeToStdout();
      }
    }
  })
  .on("--help", function() {
    console.log(`
  Examples:

    For developers:
      npm run compile:es5 && ./bin/bridgedb dataSource 'Entrez Gene'

      npm run compile:es5 && ./bin/bridgedb dataSource 'Entrez Gene'

      cat ../gpml2pvjson-js/test/expected/WP481_94171.json |\\
      jq '.entitiesById[] |'\\
        ' select(has("dbConventionalName") and .kaavioType=="SingleFreeNode") |'\\
        ' .dbConventionalName+"\t"+.dbId'
    `);
  });

program
  .command(
    "xrefsBatch [dbIdColumn] [dbConventionalNameColumn] [organismColumn]"
  )
  .description("Get xrefs for entities in a delimited file (CSV, TSV, etc.)")
  .option(
    "-d, --delimiter [string]",
    'Delimiter for file, e.g., "," or "\t". Default: ","'
  )
  .option(
    "--organism [string]",
    'If organismColumn not specified, set organism, e.g., "Homo sapiens"'
  )
  .option(
    "--dbConventionalName [string]",
    'If dbConventionalNameColumn not specified, set dbConventionalName, e.g., "Entrez Gene"'
  )
  .option("--headers [boolean]", "First row of file is headers")
  .action(function(
    dbIdColumnStr,
    dbConventionalNameColumnStr,
    organismColumnStr,
    options
  ) {
    var organismOption = options.organism;
    var dbConventionalNameOption = options.dbConventionalName;
    var headersOption = options.hasOwnProperty("headers")
      ? Boolean(options.headers)
      : false;
    var delimiterOption = options.delimiter || ",";
    var newlineOption = options.newline || "\n"; // newline character (use \r\n for CRLF files)
    var quoteOption = options.quote || '"';

    var organismColumn = typeof organismColumnStr !== "undefined"
      ? parseInt(organismColumnStr)
      : typeof organismOption === "undefined" ? 0 : null;

    var dbConventionalNameColumn = typeof dbConventionalNameColumnStr !==
      "undefined"
      ? parseInt(dbConventionalNameColumnStr)
      : typeof dbConventionalNameOption === "undefined"
        ? organismColumn === null ? 0 : organismColumn + 1
        : null;

    var dbIdColumn = typeof dbIdColumnStr !== "undefined"
      ? parseInt(dbIdColumnStr)
      : typeof dbIdOption === "undefined"
        ? dbConventionalNameColumn === null ? 0 : dbConventionalNameColumn + 1
        : null;

    var bridgeDb = new BridgeDb();

    var parser = csv({
      delimiter: delimiterOption,
      newline: newlineOption,
      quote: quoteOption,
      objectMode: true
    });

    var serialize = ndjson.serialize();

    Rx.Observable
      .fromNodeReadableStream(
        hl(process.stdin).through(parser).drop(headersOption ? 1 : 0)
      )
      .map(function(row) {
        return {
          organism: typeof organismOption !== "undefined"
            ? organismOption
            : row[organismColumn],
          dbConventionalName: typeof dbConventionalNameOption !== "undefined"
            ? dbConventionalNameOption
            : row[dbConventionalNameColumn],
          dbId: typeof dbIdOption !== "undefined" ? dbIdOption : row[dbIdColumn]
        };
      })
      .mergeMap(function(x) {
        var organism = x.organism;
        var dbConventionalName = x.dbConventionalName;
        var dbId = x.dbId;
        return bridgeDb
          .dataSourceProperties(dbConventionalName)
          .mergeMap(function(dataSource) {
            if (!dataSource || !dataSource.id) {
              return Rx.Observable.throw(
                new Error(`Cannot process "${dbConventionalName}:${dbId}"`)
              );
            }
            var id = dataSource.id + dbId;
            return bridgeDb
              .xrefs(organism, dbConventionalName, dbId)
              .toArray()
              .map(function(xrefs) {
                return {
                  id: id,
                  dbConventionalName: dbConventionalName,
                  dbId: dbId,
                  organism: organism,
                  xrefs: xrefs
                };
              });
          });
      })
      .map(function(result) {
        return (
          "\t" +
          result.id +
          "\n\t\t" +
          result.xrefs
            .map(function(xref) {
              return [xref.dataSource, xref.dbId].join("\t");
            })
            .join("\n\t\t") +
          "\n"
        );
      })
      //.throughNodeStream(serialize)
      .pipeToStdout();

    //          .mergeMap(function(dataSource) {
    //            if (!dataSource || !dataSource.id) {
    //              return Rx.Observable.throw(
    //                new Error(`Cannot process "${dbConventionalName}:${dbId}"`)
    //              );
    //            }
    //            var id = dataSource.id + dbId;
    //            return bridgeDb
    //              .xrefs(organism, dbConventionalName, dbId)
    //            /*
    //            .map(function(xref) {
    //              return [xref.dataSource, xref.dbId].join('\t');
    //            })
    //              .toArray()
    //              .map(function(xrefStrings) {
    //                return xrefStrings.join('\n');
    //              });
    //            //*/
    //            //*
    //              .toArray()
    //              .map(function(xrefs) {
    //                return {
    //                  id: id,
    //                  //dbConventionalName: dbConventionalName,
    //                  //dbId: dbId,
    //                  //organism: organism,
    //                  xrefs: xrefs
    //                };
    //              });
    //            //*/
    //          });
  })
  .on("--help", function() {
    console.log(`
  Examples:

    For developers:
      Compile, if needed:
      npm run compile:es5

      Run it, as in one of the following examples:

      echo $'1234\n1235\n' |\\
      ./bin/bridgedb xrefsBatch --organism 'Homo sapiens' --dbConventionalName 'Entrez Gene'

      ./bin/bridgedb xrefsBatch --organism 'Homo sapiens' --dbConventionalName 'Entrez Gene' \\
      <<< $'1234\n1235\n'

      echo $'dbId\n1234\n1235\n' |\\
      ./bin/bridgedb xrefsBatch --organism 'Homo sapiens' --dbConventionalName \\
        'Entrez Gene' --headers=true

      cat test/dbIds.csv |\\
      ./bin/bridgedb xrefsBatch --organism="Homo sapiens" --dbConventionalName="Entrez Gene"

      ./bin/bridgedb xrefsBatch --organism="Homo sapiens" < test/dbNamesAndIds.csv

      cat test/dbNamesAndIds.csv | ./bin/bridgedb xrefsBatch --organism="Homo sapiens"
    `);
  });

program
  .command('*')
  .action(function(cmd){
    console.error("");
    console.error('\ \ Unrecognized command "%s". Valid commands shown below:', cmd);
    program.outputHelp();
  });

program.parse(process.argv);

// If no command is specified, output help.
if (!process.argv.slice(2).length) {
  program.outputHelp();
}
