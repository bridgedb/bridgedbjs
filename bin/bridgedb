#!/usr/bin/env node

var _ = require("lodash");
var crypto = require("crypto");
var csv = require("csv-streamify");
var fs = require("fs");
var jsonpath = require('jsonpath');
var path = require("path");
var BridgeDb = require("../es5/BridgeDb").BridgeDb;
var hl = require("highland");
var ndjson = require("ndjson");
var JSONStream = require("JSONStream");
var npmPackage = require("../package.json");
var program = require("commander");
var Rx = require("rx-extra");
require("../es5/spinoffs/pipeToStdout");
require("../es5/spinoffs/toNodeStream");
var VError = require("verror");

program
  .version(npmPackage.version)
  .description("CLI client for BridgeDb ID mapping webservice.");

program.on("--help", function() {
  console.log("  Examples:");
  console.log();
  console.log("    Display xrefs in command line:");
  console.log("    $ bridgedb xrefs 'Homo sapiens' 'Entrez Gene' 1234");
  console.log();
  console.log("    Save multiple xrefs to new file:");
  console.log(
    [
      "    $ cat test/dbNamesAndIds.csv | bridgedb xrefsBatch ",
      "--organism='Homo sapiens' > ./xrefs.json"
    ].join("")
    /* TODO why doesn't the following work?
    [
      "    $ bridgedb xrefsBatch ",
      "--organism='Homo sapiens' --xrefDataSourceNS='Entrez Gene' ",
      "< ./test/dbNamesAndIds.csv > ./xrefs.json"
    ].join("")
    //*/
  );
});

// path options
// https://www.npmjs.com/package/node-red-contrib-json
// JSONata: https://github.com/jsonata-js/jsonata/blob/master/tutorial.md
// JSON Path: http://goessner.net/articles/JsonPath/
// jq
// ...

function jsonPathToLodashPath(jsonPath) {
  const jsonPathParsed = parseJsonPath(jsonPath);
  const unhandledOperators = _.intersection(jsonPathParsed, ["..", "*"]);
  if (unhandledOperators.length > 0) {
    throw new Error(`Cannot currently handle ${unhandledOperators.join()} operator(s).`);
  }
  return jsonPathParsed.filter(s => s !== "$").map(s => s === true ? "*" : s).join(".");
}

function serializeJsonPath(pathComponents) {
  const unhandledOperators = _.intersection(pathComponents, [".."]);
  if (unhandledOperators.length > 0) {
    throw new Error(`Cannot currently handle ${unhandledOperators.join()} operator(s).`);
  }
  return pathComponents.map(s => s === true ? "*" : s).join(".");
}

function parseJsonPath(path) {
  if (path.indexOf("..") > -1) {
    throw new Error('Cannot currently handle ".." operator.');
  }
  return path.split(".").map(s => s === "*" ? true : s);
}

/************
 * jq
 **********/

function jqToJSONStreamPath(jqPath) {
  const jqPathParsed = parseJQPath(jqPath);
  const unhandledOperators = _.intersection(jqPathParsed, [".."]);
  if (unhandledOperators.length > 0) {
    throw new Error(`Cannot currently handle ${unhandledOperators.join()} operator(s).`);
  }
  return jqPathParsed.map(s => s === true ? "*" : s).join(".");
}

function jqPathToLodashParsedPath(jqPath) {
  const jqPathParsed = parseJQPath(jqPath);
  const unhandledOperators = _.intersection(jqPathParsed, ["..", true]);
  if (unhandledOperators.length > 0) {
    throw new Error(`Cannot currently handle ${unhandledOperators.join()} operator(s).`);
  }
  return jqPathParsed;
}

/*
function serializeJQPath(pathComponents) {
  const unhandledOperators = _.intersection(pathComponents, [".."]);
  if (unhandledOperators.length > 0) {
    throw new Error(`Cannot currently handle ${unhandledOperators.join()} operator(s).`);
  }
  return pathComponents.map(s => s === true ? "*" : s).join(".");
}
//*/

function parseJQPath(path) {
  return path.replace(/^\./, "")
    .split(".")
    .reduce((acc, s) => {
      (s.match(/(\w+)?(\[\w*\])?/) || [])
        .slice(1)
        .filter(_.negate(_.isUndefined))
        .map(s => s === "[]" ? true : s.replace(/\[(\w+)\]/, "\1"))
        //.map(s => s.replace(/\[(\w+)\]/, "\1").replace(/\[\]/, true))
        .forEach(function(s) {
          acc.push(s);
        });
      return acc;
    }, []);
}

function resolveJQPath(base, relativePath) {
  if (base.endsWith(".") && relativePath.startsWith(".")) {
    return base + relativePath.replace(/^\./, "");
  } else if (base.endsWith(".") || relativePath.startsWith(".")) {
    return base + relativePath;
  } else {
    return base + "." + relativePath;
  }
}

/* _.get doesn't allow for path to indicate identity.
 * this function allows the parsed path to be [], indicating
 * we just want to return the entire value.
 */
function getByParsedPath(value, path) {
  if (path.length > 0) {
    return _.get(
      value,
      path
    );
  } else {
    return value;
  }
}

const DEFAULT_ADDMAPPEDXREFS_BASE = ".";
const NEST0_OBJECT_KEY = "BRIDGEDB_NEST0_OBJECT_KEY";
program
  .command(
    `addMappedXrefs <organism> <pathToXrefNS> <pathToXrefID>
    <pathToAddMappedXrefs> [mapToXrefNS...]`
  )
  .option(
    "-b,--base [path]",
    `jq expression that is prepended to relative paths.
                  Default: "${DEFAULT_ADDMAPPEDXREFS_BASE}"

                  It's similar to HTML or XML BASE. More info:
                  https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base
                  https://www.w3.org/TR/xmlbase/`,
    (base) => !!base ? base : DEFAULT_ADDMAPPEDXREFS_BASE
  )
  .action(function(
    organism,
    pathToXrefNS,
    pathToXrefID,
    pathToAddMappedXrefs,
    mapToXrefNSes,
    optionsRaw
  ) {
    //*
    var bridgeDb = new BridgeDb();
    //*/
    /*
    var bridgeDb = new BridgeDb({
      baseIri: "http://localhost:4522/",
      dataSourcesHeadersIri: "http://localhost:4522/datasources_headers.txt",
      dataSourcesMetadataIri: "http://localhost:4522/datasources.txt"
    });
    //*/

    const options = _.defaults(optionsRaw, {
      base: DEFAULT_ADDMAPPEDXREFS_BASE
    });
    var base = options.base;

    var {common, relPaths} = _.zip
      .apply(
        undefined,
        [pathToXrefNS, pathToXrefID].map(p => resolveJQPath(base, p)).map(parseJQPath)
      )
      .reduce(
        function(acc, pair, i) {
          const {common, relPaths} = acc;
          const [first, second] = pair;
          acc.matched = acc.matched && first === second;
          if (acc.matched) {
            common.push(first);
          } else {
            pair.forEach(function(p, i) {
              if (acc.relPaths[i]) {
                acc.relPaths[i].push(p);
              } else {
                acc.relPaths[i] = [p];
              }
            });
          }
          return acc;
        },
        { matched: true, common: [], relPaths: [] }
      );

    const commonIndexOfTrue = common.indexOf(true);
    var JSONStreamParentPath = common.slice(
      0,
      commonIndexOfTrue > -1 ? commonIndexOfTrue : common.length - 1
    );
    var JSONStreamPath;
    if (common.length > 0) {
      JSONStreamPath = _.concat(JSONStreamParentPath, [{emitPath: true}]);
    } else {
      JSONStreamPath = [];
      // NOTE: using emitPath doesn't work when the input is just one object (Map).
      // We want to get the following to be consistent with other inputs:
      // {"path": [], value: THE_INPUT_OBJECT}
      // But we actually get the key/value pairs of the input object.
      // So we need to use the kludge above.
      //var JSONStreamPath = [{emitPath: true}];
    }
    var containerParser = JSONStream.parse(JSONStreamPath.length > 0 ? JSONStreamPath : undefined);

    var rootKey = common[0];

    const [relPathToXrefDataSourceNSParsed, relPathToXrefDataSourceIDParsed] = relPaths;

    if (_.intersection(_.uniq(relPaths), [true]).length > 0) {
      if (common.lastIndexOf(true) > 1) {
        throw new Error(`Currently unable to handle more than one level of nesting before "[]".

        These are OK:
        .a
        .a.z
        .a.z.x
        .a.z.x.y
        .[]
        .[].z
        .[].z.y
        .[].z.y.x
        .a[]
        .a[].z
        .a[].z.y
        .a[].z.y.x
      
        These are not:
        .a.b[]
        .a.b.c[]
        `);
      } else {
      throw new Error(`There must only be one xrefNS per xrefID, but
      provided paths may violate that constraint.
      `);
      }
    }

    const pathToAddMappedXrefsParsed = parseJQPath(resolveJQPath(base, pathToAddMappedXrefs));
    /*
    console.warn('common');
    console.warn(common);
    console.warn('JSONStreamParentPath');
    console.warn(JSONStreamParentPath);
    console.warn('relPaths');
    console.warn(relPaths);
    console.warn('pathToAddMappedXrefsParsed');
    console.warn(pathToAddMappedXrefsParsed);
    //*/
    const addLocally = pathToAddMappedXrefsParsed.join().indexOf(common.join()) === 0;

    var headerStream = hl("header", containerParser).map(function(result) {
      return {
        event: "header",
        path: [],
        value: result
      };
    });

    var dataStream = hl("data", containerParser);

    var footerStream = hl("footer", containerParser).map(function(result) {
      return {
        event: "footer",
        path: [],
        value: result
      };
    });

    var endStream = hl("end", containerParser);

    var lastCommonKey = common.slice(-1)[0] || NEST0_OBJECT_KEY;
    var parsedDataStream = dataStream
      .map(function(data) {
        if (JSONStreamPath.length > 0) {
          return data;
        } else {
          // This kludge is needed to handle un-nested objects as input, e.g.,
          // {"id": "abc123", "dbConventionalName": "Entrez Gene", "dbId": "1234"}
          // We want process them same way we do for other inputs to JSONStream.parse.
          return {path: [NEST0_OBJECT_KEY], value: data};
        }
      })
      .reduce({ inputXrefsById: {} }, function(acc, data) {
        const {value, path} = data;
        const valueKey = path.slice(-1)[0];
        if (!("valuesByKey" in acc)) {
          acc.valuesByKey = _.isFinite(valueKey) ? [] : {};
        }
        var valuesByKey = acc.valuesByKey;

        var entityKey = lastCommonKey !== true ? lastCommonKey : path.slice(-1)[0];

        var entityPathRelToValue = common.slice(JSONStreamPath.length)
          .map(s => s === true ? entityKey : s);
        var entity = getByParsedPath(
          value,
          entityPathRelToValue
        );
        /*
        console.warn('data');
        console.warn(data);
        console.warn('path');
        console.warn(path);
        console.warn('entityKey');
        console.warn(entityKey);
        console.warn('entityPathRelToValue');
        console.warn(entityPathRelToValue);
        console.warn('valueKey');
        console.warn(valueKey);
        console.warn('entity is plain object: ' + _.isPlainObject(entity));
        //*/
        var xrefNS = getByParsedPath(
          entity,
          relPathToXrefDataSourceNSParsed
        );
        var xrefID = getByParsedPath(
          entity,
           relPathToXrefDataSourceIDParsed
        );
        if (xrefNS && xrefID) {
          const entityPathRelToValuesByKey = [valueKey].concat(entityPathRelToValue);
          var xrefNSAndID = [xrefNS, xrefID].join(":");
          if (acc.inputXrefsById[xrefNSAndID]) {
            acc.inputXrefsById[xrefNSAndID].entityPaths.push(entityPathRelToValuesByKey);
          } else {
            acc.inputXrefsById[xrefNSAndID] = {
              entityPaths: [entityPathRelToValuesByKey],
              NS: xrefNS,
              ID: xrefID
            };
          }
        }
        valuesByKey[valueKey] = value;
        /*
        console.warn('value');
        console.warn(value);
        console.warn('valueKey');
        console.warn(valueKey);
        //*/
        return acc;
      })
      .flatMap(function(reducedData) {
        /*
        console.warn('reducedData');
        console.warn(JSON.stringify(reducedData, null, '  '));
        //*/
        var {inputXrefsById, valuesByKey} = reducedData;
        var inputXrefs = _.values(reducedData.inputXrefsById);
        var inputXrefNSes = _.uniq(
          inputXrefs.map(function(inputXref) {
            return inputXref.NS;
          })
        );

        var xrefNSFormatter$;
        if (!!mapToXrefNSes) {
          xrefNSFormatter$ = hl([mapToXrefNSes[0]])
            .flatMap(function(mapToXrefNS) {
              return bridgeDb
                .dataSourceNameToColumnTerm(mapToXrefNS)
                .first()
                .map(function(mapToXrefNSType) {
                  return bridgeDb.convertDataSourceNameTo(mapToXrefNSType);
                })
                .toNodeStream()
            });
        } else {
          xrefNSFormatter$ = hl([Rx.Observable.of])
        }

        return xrefNSFormatter$
          .flatMap(function(xrefNSFormatter) {
            return hl(inputXrefNSes)
              .flatMap(function(inputXrefNS) {
                return bridgeDb
                  .dataSourceNameToColumnTerm(inputXrefNS)
                  .filter(function(inputXrefNSType) {
                    return inputXrefNSType !== null;
                  })
                  .map(function(inputXrefNSType) {
                    return {inputXrefNS, inputXrefNSType};
                  })
                  .toNodeStream();
              })
              .flatMap(function({inputXrefNS, inputXrefNSType}) {
                return hl(
                  inputXrefs.filter(function(inputXref) {
                    return inputXref.NS === inputXrefNS;
                  })
                  .map(function(inputXref) {
                    inputXref.NSType = inputXrefNSType;
                    return inputXref;
                  })
                );
              })
              .collect()
              .flatMap(function(inputXrefs) {
                if (inputXrefs.length === 0) {
                  console.warn("No valid input xrefs found.");
                  return hl();
                }
                return bridgeDb
                  .xrefsBatch(
                    organism,
                    inputXrefs.map(({NS}) => NS),
                    inputXrefs.map(({ID}) => ID)
                    //dataSourceFilter?: string
                  )
                  .map(function(xrefsResult) {
                    const {inputDataSource, inputDbId} = xrefsResult;
                    xrefsResult.inputId = [
                      inputDataSource,
                      inputDbId
                    ].join(":");
                    return xrefsResult;
                  })
                  .filter(function(xrefsResult) {
                    // TODO we can probably get rid of this. It's only here
                    // b/c my dummy server returns incorrect xrefs.
                    return xrefsResult.inputId in inputXrefsById;
                  })
                  .mergeMap(function(xrefsResult) {
                    return Rx.Observable.from(xrefsResult.xrefs)
                      .mergeMap(function(xref) {
                        return xrefNSFormatter(xref.dataSource)
                          .filter(xrefNS => !mapToXrefNSes ||
                            mapToXrefNSes.indexOf(xrefNS) > -1)
                          .map(function(xrefNS) {
                            return {
                              NS: xrefNS,
                              ID: xref.dbId
                            };
                          });
                      })
                      .toArray()
                      .map(function(xrefs) {
                        xrefsResult.xrefs = xrefs;
                        return xrefsResult;
                      });
                  })
                  .toArray()
                  .toNodeStream()
                  .map(function(xrefsResults) {
                    /*
                     * Consider specifying the xref in entitiesById and
                          then adding the mappings to sameAs.
                     * Then for the SVG, we might only use "type" for class
                          but use type + mapped sameAs for typeof???
                      //*/

                    xrefsResults.forEach(function(xrefsResult) {
                      var inputXrefId = xrefsResult.inputId;
                      /*
                      console.warn('xrefsResult');
                      console.warn(xrefsResult);
                      console.warn('valuesByKey');
                      console.warn(valuesByKey);
                      //*/
                      if (addLocally) {
                        inputXrefsById[
                          inputXrefId
                        ].entityPaths.forEach(function(entityPath) {
                          var entity = getByParsedPath(valuesByKey, entityPath);
                          var whereToAdd = pathToAddMappedXrefsParsed.slice(
                            common.length);
                          var xrefContainer = getByParsedPath(entity, whereToAdd) || [];
                          /*
                          console.warn('entity');
                          console.warn(entity);
                          console.warn('entityPath');
                          console.warn(entityPath);
                          console.warn('whereToAdd');
                          console.warn(whereToAdd);
                          console.warn('xrefContainer');
                          console.warn(xrefContainer);
                          //*/

                          var xrefMapping;
                          if (!_.isArray(xrefContainer)) {
                            xrefsResult.xrefs.map(function(xref) {
                              var {NS, ID} = xref;
                              if (!(NS in xrefContainer)) {
                                xrefContainer[NS] = ID;
                              } else {
                                const preexistingNSValue = xrefContainer[NS];
                                if (_.isString(preexistingNSValue)) {
                                  if (preexistingNSValue !== ID) {
                                    xrefContainer[NS] = [preexistingNSValue, ID];
                                  }
                                } else if (_.isArray(preexistingNSValue)) {
                                  if (preexistingNSValue.indexOf(ID) === -1) {
                                    xrefContainer[NS].push(ID);
                                  }
                                } else {
                                  console.warn(`Property ${NS} already set at specified path, and
                                  it's not a string or array. Skipping addition of ${ID}.`);
                                  console.warn(JSON.stringify(entity));
                                }
                              }
                            });
                          } else {
                            xrefsResult.xrefs.map(function(xref) {
                              var mappedXref = [xref.NS, xref.ID].join(":");
                              if (xrefContainer.indexOf(mappedXref) === -1) {
                                xrefContainer.push(mappedXref);
                              }
                            });
                          }
                          if (xrefContainer !== entity) {
                            _.set(entity, whereToAdd, xrefContainer);
                          }
                        });
                      } else {
                        var xrefMapping;
                        var xrefMappingStarter = {
                          closeMatch: []
                        };
                        if (!_.isArray(valuesByKey)) {
                          if (!(inputXrefId in valuesByKey)) {
                            xrefMapping = valuesByKey[inputXrefId] =
                              xrefMappingStarter;
                          } else {
                            xrefMapping = valuesByKey[inputXrefId];
                          }
                        } else {
                          xrefMapping = _.find(
                            ({id}) => id === inputXrefId,
                            valuesByKey
                          );
                          if (!xrefMapping) {
                            xrefMapping = xrefMappingStarter;
                            valuesByKey.push(xrefMapping);
                          }
                        }

                        if (!("id" in xrefMapping)) {
                          xrefMapping.id = inputXrefId;
                        }

                        if (!("closeMatch" in xrefMapping)) {
                          xrefMapping.closeMatch = [];
                        }
                        var closeMatch = xrefMapping.closeMatch;
                        xrefsResult.xrefs.map(function(xref) {
                          var mappedXref = [xref.NS, xref.ID].join(":");
                          if (closeMatch.indexOf(mappedXref) === -1) {
                            closeMatch.push(mappedXref);
                          }
                        });
                      }
                    });

                    return {
                      event: "data",
                      path: JSONStreamParentPath,
                      value: NEST0_OBJECT_KEY in valuesByKey
                        ?
                          valuesByKey[NEST0_OBJECT_KEY]
                        :
                          valuesByKey
                    };
                  });
              });
          });
      });

    process.stdin.pipe(containerParser);

    endStream.each(function() {
      headerStream.write(hl.nil);
      dataStream.write(hl.nil);
      footerStream.write(hl.nil);
      /*
      headerStream.end();
      dataStream.end();
      footerStream.end();
      //*/
    });

    var stringifier;
    var i = 0;
    return hl([headerStream, parsedDataStream, footerStream])
      .merge()
      .reduce({}, function(acc, result) {
        var {path, value, event} = result;
        /*
        console.warn('result');
        console.warn(result);
        //*/
        if (_.isArray(value)) {
          if (i === 0) {
            stringifier = JSONStream.stringify();
            if (_.isEmpty(path)) {
              acc = [];
            }
          }
          if (_.isEmpty(path)) {
            value.forEach(function(v) {
              acc.push(v);
            });
          } else {
            _.updateWith(
              acc,
              path,
              (nsValue) => typeof nsValue === 'undefined'
                ?
                value
                :
                _.isArray(nsValue) ? nsValue.concat(value) : _.assign(nsValue, value),
              (nsValue, key, nsObject) => nsValue || _.isFinite(parseInt(key)) ? Array : Object
            );
          }
        } else {
          if (i === 0) {
            stringifier = JSONStream.stringify(false);
            //stringifier = JSONStream.stringifyObject();
          }
          if (_.isEmpty(path)) {
            acc = _.assign(acc, value);
          } else {
            _.updateWith(
              acc,
              path,
              (nsValue) => _.isArray(nsValue) ? nsValue.concat(value) : _.assign(nsValue, value),
              (nsValue, key, nsObject) => nsValue || _.isFinite(key) ? [] : {}
            );
          }
        }
        i += 1;
        return acc;
      })
      .flatMap(function(s) {
        return hl(_.isArray(s) ? s : [s])
          .through(stringifier);
      })
      .pipe(process.stdout);
  })
  .on("--help", function() {
    console.log(`
  Stream in JSON with xrefs and this method will map those xrefs
  to equivalents from other datasources and add the mapped xrefs
  to the JSON, piping it back out without otherwise changing it.

  Paths use the format of basic jq filters, e.g., any of these:
        .a
        .a.z
        .a.z.x
        .a.z.x.y
        .[]
        .[].z
        .[].z.y
        .[].z.y.x
        .a[]
        .a[].z
        .a[].z.y
        .a[].z.y.x
    More info: https://stedolan.github.io/jq/manual/v1.5/#Basicfilters

  Examples:

    echo '[{"dbConventionalName": "Entrez Gene", "dbId": "1234"}]' |\\
    bridgedb addMappedXrefs \\
      Human \\
      ".[].dbConventionalName" \\
      ".[].dbId" \\
      ".[]" \\
      ensembl ncbigene uniprot wikidata

    For developers:

    cat ./test/inputs/nest0-array.json |\\
    ./bin/bridgedb addMappedXrefs \\
      Human \\
      ".[].dbConventionalName" \\
      ".[].dbId" \\
      ".[].type" \\
      ensembl ncbigene uniprot wikidata |\\
    jq .

    cat ./test/inputs/nest0-array.json |\\
    ./bin/bridgedb addMappedXrefs Human \\
      ".[].dbConventionalName" ".[].dbId" \\
      ".[]" \\
      ensembl ncbigene uniprot wikidata |\\
    jq .

    cat ./test/inputs/nest1-object.json |\\
    ./bin/bridgedb addMappedXrefs Human \\
      ".entitiesById[].dbConventionalName" ".entitiesById[].dbId" \\
      ".entitiesById[].type" \\
      ensembl ncbigene uniprot wikidata |\\
    jq .

    cat ./test/inputs/nest1-object.json |\\
    ./bin/bridgedb addMappedXrefs Human \\
      ".entitiesById[].dbConventionalName" ".entitiesById[].dbId" \\
      ".entitiesById" \\
      ensembl ncbigene uniprot wikidata |\\
    jq .

  Note: This has been tested on the pvjson format from gpml2pvjson:
    <https://github.com/wikipathways/gpml2json>
    If you are using it on another format, exercise caution and verify your results.
      
    `);
  });

/*
echo '[{"dbId": "1234", "xrefDataSourceNS": "Entrez Gene"},'\
    '{"dbId": "1235", "xrefDataSourceNS": "Entrez Gene"}]' |\
  jq -rc .[] |\
  ./bin/bridgedb enrichBatch " Homo sapiens" xrefDataSourceNS dbId

cat data.txt | jq -rc . | bin/bridgedb enrichBatch "Homo sapiens" xrefDataSourceNS dbId

echo '[{"dbId": "1234", "xrefDataSourceNS": "Entrez Gene"},'\
    '{"dbId": "1235", "xrefDataSourceNS": "Entrez Gene"}]' |\
  jq -rc .[] |\
  ./bin/bridgedb enrich "Homo sapiens" xrefDataSourceNS dbId ncbigene ensembl wikidata
//*/

program
  .command("xrefs <organism> <dbConventionalName> <dbId>")
  .action(function(organism, dbConventionalName, dbId) {
    var serialize = ndjson.serialize();
    var bridgeDb = new BridgeDb();
    bridgeDb
      .xrefs(organism, dbConventionalName, dbId)
      .subscribe(xrefsResponseQueue)
      .throughNodeStream(serialize)
      .pipeToStdout();
  })
  .on("--help", function() {
    console.log(`
  Examples:
    cat input.json |\
      ./bin/bridgedb addMapppedXrefs Human "entitiesById.*.dbConventionalName"\
        "entitiesById.*.dbId" "type" ensembl |\
      jq .

    For developers:
      npm run compile:es5 && ./bin/bridgedb xrefs 'Homo sapiens' 'Entrez Gene' '1234'

      cat test/dbNamesAndIds.csv |\\
      while read ln; do \\
        xrefDb=\${echo $ln | sed s/,.*//g}; \\
        xrefId=\${echo $ln | sed 's/^.*,//g'}; \\
        echo "$xrefDb" "$xrefId"; \\
        ./bin/bridgedb xrefs "Homo sapiens" "$xrefDb" "$xrefId"; \\
      done

      cat test/dbNamesAndIds.csv |\
      while read ln; do \\
        xrefDb=\${echo $ln | sed s/,.*//g}; \\
        xrefId=\${echo $ln | sed 's/^.*,//g'}; \\
        echo "$xrefDb" "$xrefId"; \\
        ./bin/bridgedb xrefs "Homo sapiens" "$xrefDb" "$xrefId" |\\
        jq ". | .dbId | {\"$xrefId\": .}" |\\
        tee $xrefId.tsv & \\
      done
    `);
  });

program
  .command("datasource <input> [as]")
  .option(
    "--format [string]",
    `Column format to return when identifying a data source name format: term or iri.
    Default: "term"`
  )
  .action(function(input, as, options) {
    var format = !!options["format"] ? options["format"] : "term";
    var serialize = ndjson.serialize();
    var bridgeDb = new BridgeDb();
    if (!!as) {
      bridgeDb
        .convertDataSourceNameTo(as, input)
        .throughNodeStream(serialize)
        .pipeToStdout();
    } else {
      if (format === "term") {
        bridgeDb
          .dataSourceNameToColumnTerm(input)
          .throughNodeStream(serialize)
          .pipeToStdout();
      } else {
        bridgeDb
          .dataSourceNameToColumnIri(input)
          .throughNodeStream(serialize)
          .pipeToStdout();
      }
    }
  })
  .on("--help", function() {
    console.log(`
  Examples:

    For developers:
      npm run compile:es5 && ./bin/bridgedb dataSource 'Entrez Gene'

      npm run compile:es5 && ./bin/bridgedb dataSource 'Entrez Gene'

      cat ../gpml2pvjson-js/test/expected/WP481_94171.json |\\
      jq '.entitiesById[] |'\\
        ' select(has("dbConventionalName") and .kaavioType=="SingleFreeNode") |'\\
        ' .dbConventionalName+"\t"+.dbId'
    `);
  });

program
  .command(
    "xrefsBatch [dbIdColumn] [dbConventionalNameColumn] [organismColumn]"
  )
  .description("Get xrefs for entities in a delimited file (CSV, TSV, etc.)")
  .option(
    "-d, --delimiter [string]",
    'Delimiter for file, e.g., "," or "\t". Default: ","'
  )
  .option(
    "--organism [string]",
    'If organismColumn not specified, set organism, e.g., "Homo sapiens"'
  )
  .option(
    "--dbConventionalName [string]",
    'If dbConventionalNameColumn not specified, set dbConventionalName, e.g., "Entrez Gene"'
  )
  .option("--headers [boolean]", "First row of file is headers")
  .action(function(
    dbIdColumnStr,
    dbConventionalNameColumnStr,
    organismColumnStr,
    options
  ) {
    var organismOption = options.organism;
    var dbConventionalNameOption = options.dbConventionalName;
    var headersOption = options.hasOwnProperty("headers")
      ? Boolean(options.headers)
      : false;
    var delimiterOption = options.delimiter || ",";
    var newlineOption = options.newline || "\n"; // newline character (use \r\n for CRLF files)
    var quoteOption = options.quote || '"';

    var organismColumn = typeof organismColumnStr !== "undefined"
      ? parseInt(organismColumnStr)
      : typeof organismOption === "undefined" ? 0 : null;

    var dbConventionalNameColumn = typeof dbConventionalNameColumnStr !==
      "undefined"
      ? parseInt(dbConventionalNameColumnStr)
      : typeof dbConventionalNameOption === "undefined"
        ? organismColumn === null ? 0 : organismColumn + 1
        : null;

    var dbIdColumn = typeof dbIdColumnStr !== "undefined"
      ? parseInt(dbIdColumnStr)
      : typeof dbIdOption === "undefined"
        ? dbConventionalNameColumn === null ? 0 : dbConventionalNameColumn + 1
        : null;

    var bridgeDb = new BridgeDb();

    var parser = csv({
      delimiter: delimiterOption,
      newline: newlineOption,
      quote: quoteOption,
      objectMode: true
    });

    var serialize = ndjson.serialize();

    Rx.Observable
      .fromNodeReadableStream(
        hl(process.stdin).through(parser).drop(headersOption ? 1 : 0)
      )
      .map(function(row) {
        return {
          organism: typeof organismOption !== "undefined"
            ? organismOption
            : row[organismColumn],
          dbConventionalName: typeof dbConventionalNameOption !== "undefined"
            ? dbConventionalNameOption
            : row[dbConventionalNameColumn],
          dbId: typeof dbIdOption !== "undefined" ? dbIdOption : row[dbIdColumn]
        };
      })
      .mergeMap(function(x) {
        var organism = x.organism;
        var dbConventionalName = x.dbConventionalName;
        var dbId = x.dbId;
        return bridgeDb
          .dataSourceProperties(dbConventionalName)
          .mergeMap(function(dataSource) {
            if (!dataSource || !dataSource.id) {
              return Rx.Observable.throw(
                new Error(`Cannot process "${dbConventionalName}:${dbId}"`)
              );
            }
            var id = dataSource.id + dbId;
            return bridgeDb
              .xrefs(organism, dbConventionalName, dbId)
              .toArray()
              .map(function(xrefs) {
                return {
                  id: id,
                  dbConventionalName: dbConventionalName,
                  dbId: dbId,
                  organism: organism,
                  xrefs: xrefs
                };
              });
          });
      })
      .map(function(result) {
        return (
          "\t" +
          result.id +
          "\n\t\t" +
          result.xrefs
            .map(function(xref) {
              return [xref.dataSource, xref.dbId].join("\t");
            })
            .join("\n\t\t") +
          "\n"
        );
      })
      //.throughNodeStream(serialize)
      .pipeToStdout();

    //          .mergeMap(function(dataSource) {
    //            if (!dataSource || !dataSource.id) {
    //              return Rx.Observable.throw(
    //                new Error(`Cannot process "${dbConventionalName}:${dbId}"`)
    //              );
    //            }
    //            var id = dataSource.id + dbId;
    //            return bridgeDb
    //              .xrefs(organism, dbConventionalName, dbId)
    //            /*
    //            .map(function(xref) {
    //              return [xref.dataSource, xref.dbId].join('\t');
    //            })
    //              .toArray()
    //              .map(function(xrefStrings) {
    //                return xrefStrings.join('\n');
    //              });
    //            //*/
    //            //*
    //              .toArray()
    //              .map(function(xrefs) {
    //                return {
    //                  id: id,
    //                  //dbConventionalName: dbConventionalName,
    //                  //dbId: dbId,
    //                  //organism: organism,
    //                  xrefs: xrefs
    //                };
    //              });
    //            //*/
    //          });
  })
  .on("--help", function() {
    console.log(`
  Examples:

    For developers:
      Compile, if needed:
      npm run compile:es5

      Run it, as in one of the following examples:

      echo $'1234\n1235\n' |\\
      ./bin/bridgedb xrefsBatch --organism 'Homo sapiens' --dbConventionalName 'Entrez Gene'

      ./bin/bridgedb xrefsBatch --organism 'Homo sapiens' --dbConventionalName 'Entrez Gene' \\
      <<< $'1234\n1235\n'

      echo $'dbId\n1234\n1235\n' |\\
      ./bin/bridgedb xrefsBatch --organism 'Homo sapiens' --dbConventionalName \\
        'Entrez Gene' --headers=true

      cat test/dbIds.csv |\\
      ./bin/bridgedb xrefsBatch --organism="Homo sapiens" --dbConventionalName="Entrez Gene"

      ./bin/bridgedb xrefsBatch --organism="Homo sapiens" < test/dbNamesAndIds.csv

      cat test/dbNamesAndIds.csv | ./bin/bridgedb xrefsBatch --organism="Homo sapiens"
    `);
  });

program
  .command('*')
  .action(function(cmd){
    console.error("");
    console.error('\ \ Unrecognized command "%s". Valid commands shown below:', cmd);
    program.outputHelp();
  });

program.parse(process.argv);

// If no command is specified, output help.
if (!process.argv.slice(2).length) {
  program.outputHelp();
}
